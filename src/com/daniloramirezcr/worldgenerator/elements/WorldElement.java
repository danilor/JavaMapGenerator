package com.daniloramirezcr.worldgenerator.elements;
import com.daniloramirezcr.worldgenerator.utilities.Coordinates;
import com.daniloramirezcr.worldgenerator.utilities.Direction;
import com.daniloramirezcr.worldgenerator.utilities.Math.LinearFunction;
import com.daniloramirezcr.worldgenerator.utilities.Math.Point;
import com.daniloramirezcr.worldgenerator.utilities.RandomUtil;

import java.util.*;

public class WorldElement {


    // This is the autogenerated ID for this world element
    private String id = "";

    // This is the type of the world element
    private WorldElementType type = null;

    // These are the coordinates where this is located
    private Coordinates coord = new Coordinates(0, 0);

    /**
     * This will indicate if this element is covered by all sides
     */
    private WorldElement north = null;
    private WorldElement east = null;
    private WorldElement south = null;
    private WorldElement west = null;

    // This is the elevation factor for this world element. It should be calculated after the whole map
    // is completed
    private int elevation = 0;

    /**
     *
     */
    public WorldElement(Coordinates c) {
        WorldElementType[] w = WorldElementType.getArrayWithProbabilityFactor();
        RandomUtil r = RandomUtil.getInstance();
        this.type = w[r.getRandomObject().nextInt(w.length)];
        this.coord = c;
        this.generateOwnID();
    }

    /**
     *
     * @param type WordElementType
     */
    public WorldElement(Coordinates c, WorldElementType type) {
        this.type = type;
        this.coord = c;
        this.generateOwnID();
    }

    /**
     *
     * @return WorldElementType
     */
    public WorldElementType getType() {
        return type;
    }

    /**
     *
     * @param type WorldElementType
     */
    public void setType(WorldElementType type) {
        this.type = type;
    }

    @Override
    public String toString() {
//        return super.toString();
        if (this.isAssigned()) {
            return this.type.toString().substring(0, 1);
        } else {
            return "â–¯";
        }
    }

    /**
     * Getting the coordinates
     *
     * @return Coordinates
     */
    public Coordinates getCoord() {
        return coord;
    }

    /**
     * Just to know if this element is already assigned
     *
     * @return boolean
     */
    public boolean isAssigned() {
        return !(this.type.getIdentifier().equals("U"));
    }


    /**
     * Just to know if this element is already covered
     */
    public boolean isCovered() {
        return (this.north != null && this.east != null && this.south != null && this.west != null);
    }


    /**
     * It sets the neighbor in a certain direction
     *
     * @param d Direction The direction of the neighbor
     * @param e WorldElement The element that is in that direction. Should be stored as reference.
     * @return boolean It checks if the element is already fully covered
     */
    public boolean setNeighbor(Direction d, WorldElement e) {
        if (d == Direction.N) {
            this.north = e;
        }
        if (d == Direction.E) {
            this.east = e;
        }
        if (d == Direction.S) {
            this.south = e;
        }
        if (d == Direction.W) {
            this.west = e;
        }
        return this.isCovered();
    }

    /**
     * Gets the current terrain elevation
     *
     * @return int
     */
    public int getElevation() {
        return elevation;
    }



    public void findElevation(int maxFactor){
        List<Integer> distances = new ArrayList<Integer>();

        distances.add( this.getNorthDistance(0) );
        distances.add( this.getSouthDistance(0) );
        distances.add( this.getEastDistance(0) );
        distances.add( this.getWestDistance(0) );

        Collections.sort(distances);
        /*
        min_elevation / min_distance @ max_elevation[X] / max_distance
         */

        int minValue = distances.get(0);
        int maxValue = distances.get(distances.size() -1);

        Point p1 = new Point(0,this.type.getMinElevation());
        Point p2 = new Point(maxFactor, this.type.getMaxElevation());

        LinearFunction f = new LinearFunction(p1,p2);

        int gotElevation = (int)f.getY( minValue );

        this.elevation = gotElevation;

    }


    public int getNorthDistance(int accumulator){
        if( this.north.type.getIdentifier().equals( this.type.getIdentifier() ) && !this.north.getId().equals(this.getId())  ){
            accumulator = this.north.getNorthDistance(accumulator+1);
        }

        return accumulator;
    }

    public int getSouthDistance(int accumulator){
        if( this.south.type.getIdentifier().equals( this.type.getIdentifier() ) && !this.south.getId().equals(this.getId())  ){
            accumulator = this.south.getSouthDistance(accumulator+1);
        }

        return accumulator;
    }

    public int getEastDistance(int accumulator){
        if( this.east.type.getIdentifier().equals( this.type.getIdentifier() ) && !this.east.getId().equals(this.getId())  ){
            accumulator = this.east.getEastDistance(accumulator+1);
        }
        return accumulator;
    }

    public int getWestDistance(int accumulator){
        if( this.west.type.getIdentifier().equals( this.type.getIdentifier() ) && !this.west.getId().equals(this.getId())  ){
            accumulator = this.west.getWestDistance(accumulator+1);
        }
        return accumulator;
    }



    /**
     * It will generate an automatic uuid for this element.
     *
     * @return String Returns the UUID it was just generated
     */
    private String generateOwnID() {
        UUID uuid = UUID.randomUUID();
        this.id = uuid.toString();
        return this.id;
    }

    public String getId() {
        return id;
    }
}
